---
layout: article
---
Ты мог обратить внимание, что мы использовали  две команды для очистки сборщиков:

```
docker buildx prune -af                                
```

```
docker builder prune -af                                
```

Первый образ мы собирали командой `docker buildx build`, а второй `docker image build .`

Обрати внимание, что результат команд одинаковый, но у обеих этих сборок будет собственный отдельных кэш, который не пересекается. Имей это ввиду при использовании плагина `buildx`.

Тема управления удалённым кэшем на самом деле непростая, поскольку она обычно находится на стыке определённого CICD, определённого приложения и определённого сборщика Docker. 

Например, методика сборки NodeJS-приложения отличается от методики сборки Java, если мы хотим, чтобы Docker успешно работал с кэшами. Тоже самое и с CI-системами. В GitHub Actions на Github-hosted раннерах у нас не получится делать то, что мы могли бы делать на self-hosted раннерах, поэтому при каждом подходе будут свои ограничения.

Цель этой лекции в том, чтобы показать, что у Docker есть крутые возможности, экономящие время и ресурсы, и ты можешь это использовать. На этом всё, лекция закончена.
