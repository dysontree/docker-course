---
layout: article
---

Нас, как DevOps-инженеров, это заставляет дополнительно напрягаться, поскольку теперь требуется поддерживать образы, предназначенные для нескольких архитектур. 

Итак, нам нужно сопровождать пайплайны, чтобы наша кодовая база успешно собиралась, проверялась, хранилась и развертывалась единым манером, но для разных платформ. Под платформой далее я имею ввиду совокупность архитектуры CPU и ОС на ней.

Плагин `buildx` может помочь нам в этой задаче. Для начала, давай вспомним лекцию, когда мы сохранили образ в архив и заглянули внутрь. Мы увидели там несколько json-файлов, один из которых `manifest.json`. Внутри него есть ссылка на файл конфига:

```
cat image/manifest.json | jq
```

Это json-файл с длинным названием, начинающийся с `05455..`.

```
cat  05455a08881ea9cf0e752bc48e61bbd71a34c029bb13df01e40e3e70e0d007bd.json |jq
```

В нём есть параметр "architecture", которое в значении `amd64`. Таким образом, можно сделать вывод, что один и тот же образ может иметь разные версии своих слоёв, и это зависит от архитектуры платформы.

Ок, графически можно представить следующую последовательность, из чего именно состоит организация хранения слоёв в docker-реестрах:
-   реджистри содержат репозитории.
-   репозитории содержат теги.
-   теги ссылаются на список манифестов (manifest list).
-   в списке манифестов присутствуют описание платформы, т.е. архитектуры и ОС, а также digest, чтобы обратиться к манифесту.
-   в манифесте мы находим ссылки на слои и документ конфигурации, в котором описаны особенности компоновки слоёв.
-   слои являются архивами с файлами, которые можно скачать и импортировать в хранилище docker-хоста.

Получается, что эти `manifest lists` позволяют нам оперировать единым тегом для платформозависимых образов.
