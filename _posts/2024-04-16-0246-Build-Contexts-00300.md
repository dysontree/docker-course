---
layout: article
---

Давай предположим, что кроме файлов, необходимых для сборки, мы создали в каталоге контекста еще какие-то временные файлы. Тем не менее, в силу специфики нашего приложения, нам не избежать генерации таких вспомогательных каталогов и файлов в них, которые будут нежелательными при сборке, поскольку замедляют сборщик Docker. Для исправления мы можем настроить файл игнорирования `.dockerignore`, в который добавим список файлов и каталогов, которые Docker Builder будет игнорировать в процессе работы. Таким образом, эти файлы не будут рассматриваться как часть контекста сборки, а следовательно не будут отправлены демону Docker.

```
.dockerignore
```

Контекстом сборки может быть не только локальный путь. Мы также можем указать URL-адрес с tar-архивом или репозиторием кода, в котором размещены файлы нашего приложения. В этом случае, как ты видишь, сначала будет клонирован репозиторий кода, а затем из него построится образ. 

```
build https://github.com/rotoro-cloud/webapp.git
```

Указывая URL-адрес с git, мы можем дополнительно указать ссылку на ветку, использовав символ решетки. Теперь после клонирования Docker сделает `git checkout` в нужную ветку, и только потом начнет сборку.

```
docker image build https://github.com/kubernetes/kompose.git#main
```
Дополнительно мы можем использовать двоеточие, чтобы указать папку в репозитории кода, которая будет использоваться в качестве контекста сборки.

```
docker build https://github.com/kubernetes/test-infra.git#master:images/bigquery
```

Как я уже говорил, команда `docker build` ожидает файл с названием Dockerfile внутри контекста сборки, в котором находятся инструкции по созданию образа. Но мы можем указать другой Dockerfile при помощи параметра `-f`, за которым следует имя альтернативного Dockerfile. Таким образом директория контекста может использоваться повторно. 

Предположим, у нас в ней два файла: один для производственной среды - `prod.Dockerfile`, в котором нет инструментов профилирования, все работает по SSL и т.д. и другой - `dev.Dockerfile`, в котором используются библиотеки для среды разработки, профилировщики и т.д. Как видишь, у нас рядом лежат две версии Dockerfile, и нам очень удобно этим управлять.

```
docker  image  build  .  -f  dev.Dockerfile  -t  rotorocloud/webapp
```

```
docker  image  build  .  -f  prod.Dockerfile  -t  rotorocloud/webapp
```

Иногда, особенно в сценариях связанных с непрерывной интеграцией/доставкой тебе может встретиться вариант, когда сборка ссылается на git-репо, а Dockerfile был динамически сгенерирован `на лету`. Docker так тоже умеет, т.е. Dockerfile может быть передан отдельно от файлов контекста.

```
docker build -t myimage:latest -f- https://github.com/docker-library/hello-world.git <<EOF
FROM busybox
COPY hello.c ./
EOF
```
