---
layout: article
---
Мы можем делать это на бегущем или остановленном контейнере. И эта методика вполне себе работает. Тем не менее это не рекомендуемый подход для создания собственных образов. Если есть альтернатива, то следует предпочесть подход с инструкцией в виде Dockerfile.

Создание собственного образа с Dockerfile несет несколько преимуществ.
-   удобство в обслуживании: мы всегда знаем по каким именно инструкциям собирался данный образ. У нас может быть очень много образов, они будут иметь разные версии, но мы не будем путаться
-   отслеживаемость: эти Dockerfiles лежат в SCM, и мы всегда можем посмотреть, как менялись эти образы, всегда можем расшарить их между командами
-   безопасность: на основе команд в Dockerfile наши решения в области безопасности могут отслеживать неприемлемые действия разработчика образа и запрещать его развертывание
-   экономия ресурсов: у нас может быть выстроена иерархическая структура зависимых образов, которые строятся на общих слоях, что сильно экономит место (дедупликация)

Таким образом, этот подход с использованием `docker commit` можно использовать для создания одноразового пользовательского образа, который мы не планируем обновлять или поддерживать. Также это можно использовать для отладки существующего контейнера. Но это определенно не вариант для производственных целей, когда у нас много команд, которые будут пользоваться этим образом для разных целей, а нам нужно их поддерживать и обновлять. В этом случае подойдет Dockerfile.

Все же есть специфичные кейсы, когда приходится использовать `commit` в продакшене. Например, когда нужно в процессе сборки образа запустить внутри этого докер-образа другой Docker. В современных версиях builder имеет ограничения в части безопасности в момент сборки, но этих ограничений нет в момент работы контейнера. Таким образом, мы можем достичь своих целей только через механизм `docker commit`. Но это действительно узкие кейсы, и в остальных 99% случаев используется `чистый` Dockerfile.

Что же, это все. увидимся!
