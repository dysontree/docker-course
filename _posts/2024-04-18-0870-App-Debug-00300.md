---
layout: article
---

Если мы зайдём на docker-хост и запустим команду `ps`, то получим полный список всех процессов, без разницы контейнеризированные они или нет. С точки зрения хоста все процессы эквивалентны.

Мы можем улучшить вывод, отобразив его в виде дерева такой командой:

```
ps axlfww
```

Имей в виду, что вывод может быть очень обширным.

Здесь мы видим, что запущен один экземпляр `containerd`, который занимается работой с контейнерами, в то время, как его процесс-родитель `dockerd` занимается хранилищем и управлением.

У `dockerd` так же есть подпроцесс `docker-proxy`, который занимаются проксированием трафика.

Каждый процесс, который связан с `containerd-shim-runc-v2`, представляет собой один контейнер, и все его подпроцессы это то, что исполняется внутри контейнера.

В примере у нас один контейнер. Он отображается как `/usr/bin/containerd-shim-runc-v2`, за которым следует дополнительная информация о процессе, включая идентификатор контейнера. Сейчас у нас исполняется один экземпляр контейнера с nginx. Поскольку контейнер с fedora проспал 120 секунд и вышел, его нет в дереве процессов.

При стандартной настройке каждый контейнер с сопоставленными портами будет иметь хотя бы один процесс `docker-proxy`. В этом примере docker-proxy связан с `nginx`, в опциях мы видим `-host-port 80` и `-container-port 80`.

Благодаря такому древовидному выводу `ps` становится понятно, какой из процессов к чему относится. Но всё же, когда нагрузок много, нам придётся дополнительно фильтровать этот вывод.
