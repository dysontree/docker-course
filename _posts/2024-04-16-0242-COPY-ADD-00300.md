---
layout: article
---
Считается, что лучше использовать `COPY`. Прежде всего потому, что эта инструкция очень простая. Она только копирует файлы локально внутрь образа. Таким образом, любой, кто будет читать наш Dockerfile, даже если он новичок, сможет легко понять, что именно там происходит. 

И напротив, инструкция `ADD`, особенно в ее сложных проявлениях, может сбить с толку неискушенного разработчика, особенно если он не знает её особенностей по работе с локальными файлами tar-архивов. Потому они могут искренне недоумевать, что одна и та же команда ведет себя по-разному с tar-файлом: локально извлекая его, а по URL-адресу просто копируя. Т.е. в случае URL он скачивает содержимое и сохраняет в указанный каталог. Поэтому может быть неясно, что именно происходит в Dockerfile в данный момент.

```
FROM  	node
ADD 	https://ftp.gnu.org/gnu/tar/tar-1.35.tar.gz  /appdir/app.tar.gz 
RUN    	tar  -xf  /appdir/app.tar.gz  -C  /appdir/  \
    	&&  rm  -f  /appdir/app.tar.gz 
```

Вот здесь я показал, что для работы ADD с удалённым архивом нам требуются дополнительные инструкции. И слева, и справа мы запускали `RUN`, но справа нет дополнительной `ADD`. Это потому, что мы запустили несколько команд, в которых мы загружаем, извлекаем и удаляем, в виде одного `RUN`. Чем больше таких отдельных инструкций, тем больше слоев мы создаём. А новые слои обычно это распухание конечного образа. Также не стоит забывать, что количество слоёв в образе конечно - максимум `127`. Поэтому мы должны стараться, чтобы наши образы были как можно меньше и компактнее. Иногда этого можно добиться, используя обычную инструкцию `RUN`.

```
FROM  node
RUN mkdir -p /appdir \
    && curl -o app.tar.gz https://ftp.gnu.org/gnu/tar/tar-1.35.tar.gz  \
    && tar -xf app.tar.gz -C /appdir  \
    && rm -f app.tar.gz 
```

```
docker image build .
```

В этом примере мы делаем то же самое, что и при использовании ADD, но хотим уместиться в один слой. Наши файлы находятся на веб-сервере. Это может быть глобальный или локальный http-ресурс. Например, мы можем запустить простой веб-сервер на python в папке с Dockerfile. Далее запускаем сборку, в которой загружаем код приложения через http, извлекаем его, а затем также удаляем временные файлы. Всё это происходит в одном слое, что помогает нам свести размер образа к минимуму.
