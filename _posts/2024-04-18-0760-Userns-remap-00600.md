---
layout: article
---

```
docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```

Прежде всего обратим внимание, что куда-то исчезли все контейнеры. Ок, я снова запущу контейнер, который правил `sudoers` и проверю логи.

```
docker run -d -v /etc/sudoers:/etc/sudoers alpine sh -c "echo 'max    ALL=(ALL:ALL) ALL' >> /etc/sudoers"
```

```
docker logs 0dfac1b2f911cfc89ee2524b9b633f2de049c522860020bee47078d4ec54de65
```

Ох, запрещено. Давай вернёмся к команде sleep.

```
docker run -d alpine sleep 1h
```

```
ps aux | grep sleep | grep -v grep
```

Как видишь теперь процесс исполняется из-под длинного UID, но мы уже знаем, чей это UID.

Внутри контейнера мы в полной уверенности, что пользователь по прежнему root.

```
docker run --rm alpine id
```

Обрати внимание на пару моментов. Сама операция включения `userns-remap` не такая безобидная. Она меняет каталог расположения файлов в `/var/lib/docker`, из-за этого мы теряем все образы и контейнеры.

```
tree /var/lib/docker -L 2 -d
```

Как видишь, появилась папка `296608.296608`, которая дублирует основную структуру `/var/lib/docker`.

Второй момент в том, что мы всё равно управляем демоном, который запущен из-под root. Это таит в себе много опасностей. Именно для этого был придуман rootless Docker, т.е. методика запуска его службы не от суперпользователя, а от обычного. Это действительно сложно и заморочно. Это потому, что для обычного пользователя могут быть ограничения на файловую систему и сеть. Для dockerd эти два ресурса очень важны, и нам придётся настраивать это через механизмы Linux вручную. Поэтому в этом курсе я даже не буду показывать, как это устанавливается.

Ок, чем, кроме безопасности может быть полезен этот режим? 

 - Он полезен в разработке, когда мы делаем bind mounts с хоста в контейнер.

В обычном режиме файлы, которые создаются в контейнере, будут принадлежать хостовому root, что не удобно, если мы работаем из-под обычного юзера. В режиме `userns-remap` мы можем так настроить маппинг UIDs, чтобы контейнер всегда создавался с текущим пользователем системы, под которым мы ведём разработку. Таким образом, все файлы всегда будут принадлежать нашему рядовому пользователю, что очень удобно.

И это всё, увидимся!
