---
layout: article
---

Поскольку Docker на нашем хосте в конечном итоге запускает процесс, его также можно ограничить через механизм cgroups. В следующих лекциях мы подробно обсудим, как это сделать, а здесь обсудим механизм контрольных групп.

Обычно, объясняя cgroups используют аналогию со складом. Когда сервером является склад, то работники склада - это процессы. Эти работники бегают по складу, стараясь ухватить нужные им ресурсы, и мешают друг другу. 

Docker в этой аналогии можно сравнить с администратором, который переделал склад в офис и рассадил рабочих по отдельным кабинетам - `namespaces`. Теперь процессы не толкаются на складе, поскольку не могут свободно перемещаться по нему. Тем не менее конкуренция за ресурсы никуда не делась. И процессы могут работать по принципу, кто первый получил, то полностью и пользуется ресурсом. При таком подходе другим процессам ничего не достанется. 

Контрольные группы в этой аналогии чем-то похоже на контракт для этих работников, по которому одни получают возможность получить преференции от работодателя: один вправе съездить на курорт за счёт компании, а другие только пить кофе в кулере в коридоре.

Когда процесс впервые запускается, ему назначается время в CPU, которое разрешено использовать каждый цикл, а также объем памяти, который он может использовать в любое время. Это помогает гарантировать, что процессы будут иметь необходимые им ресурсы, не ущемляя потребностей других процессов, для которых тоже зарезервировано их собственное количество. Поэтому такие стены в виде пространств имён и контракты в виде контрольных групп позволяют ставить в рамки `шумных соседей` - процессы, которые пытаются воздействовать на стабильность других процессов.

Если продолжать аналогию, то инструменты `Seccomp`, `SELinux` и `AppArmor` чем-то напоминают офисную охрану, которые гарантируют, что даже если что-то плохое происходит, то дальше кабинета процесса-хулигана это не уйдёт.
