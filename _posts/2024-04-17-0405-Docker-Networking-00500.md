---
layout: article
---

Интерфейсы, которые показываются по команде `ip addr` в linux-контейнере на самом деле являются виртуальными. Они существуют в сетевом пространстве имен контейнера и отделены от хоста и других контейнеров. Я запустил команду `ip addr` на хосте и внутри контейнера. Обрати внимание на интерфейсы `veth1711bde@if8` хоста и `eth0@if9` контейнера.

```
ip a
```

```
docker exec 308 ip a
```

Когда Docker создает контейнер, он создает два виртуальных интерфейса, один из которых находится на стороне docker-сервера. Он прикрепляется к мосту `docker0`, а другой конец прикрепляется к пространству имён контейнера. Также отметь, что интерфейсу хоста не присвоен IP-адрес. Это потому, что этот интерфейс просто присоединен к мосту.

Ранее Docker был монолитным, но последние 8 лет он усиленно меняется и становится модульным. Отсюда огромное количество драйверов, плагинов и даже кастомных рантаймов, до которых мы ещё дойдём в курсе. Здесь та же история. При желании, мы можем заменить docker-proxy на другую реализацию. Для этого у dockerd есть специальный флаг `--userland-proxy-path`, в котором мы можем указать собственный бинарник такого прокси. 

Также мы можем вообще отключить прокси при помощи флага `userland-proxy=false`. В этом случае dockerd будет использовать `hairpin NAT` для маршрутизации трафика между локальными контейнерами. Что именно лучше - выбирать тебе:
- `docker-proxy` - это приложение, и у него есть ограничения на пропускную способность для больших файлов.
- `hairpin NAT` - это просто правила iptables, и они будут производительнее при высокой загруженности. Но их иногда приходится править вручную, особенно для внутреннего взаимодействия контейнеров, поскольку теперь всё ходит через внешний интерфейс хоста.
