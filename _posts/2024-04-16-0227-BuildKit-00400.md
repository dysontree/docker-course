---
layout: article
---
Демон BuildKit постоянно развивается и получает новые функции. Чтобы сборки вели себя предсказуемо, в Dockerfile появилась директива `# syntax`, в которой можно указать определённую версию, для которой написан этот файл инструкций. Если её не указывать или указать как `# syntax=docker/dockerfile:1`, то это будет означать использование синтаксиса версии 1 в его последнем стабильном релизе.

Кроме этого, `buildctl` понимает и другие форматы файлов сборки. Т.е. набором инструкций может быть не только файл формата Dockerfile. Это может быть интересно в тех случаях, когда используем классические Dockerfiles вместе с дополнительными инструментами. Я видел подобное при работе с **`envd`** при подготовке образов для ML. Теперь интеграция стала проще, а разработчикам не нужно следить за лишними Dockerfiles.

Мы также можем написать свой собственный синтаксис. Предположим, мы решили реализовать инструкцию `INCLUDE`, которая будет исполняться в определенной стадии сборки и объединять файловые системы текущего окружения и указанного образа.

```
buildkit/regular.Dockerfile
```

Вот Dockerfile, он строится от образа `alpine:3.12.0`. Ты можешь попробовать сам - эти файлы есть в репозитории курса `https://github.com/rotoro-cloud/docker-advanced.git`.

Итак, мы бы хотели, чтобы при использовании `INCLUDE rust:1.44-alpine3.12` скачивался бы образ `rust:1.44-alpine3.12`, а его файлы были бы объединены с теми, что уже присутствуют в `alpine:3.12.0`. То же самое и для `python:3.8.3-alpine3.12`. Мы хотим, чтобы этот образ дополнил микс из двух предыдущих.

Если мы запустим классический `docker build`, то получим ошибку, что инструкции `INCLUDE` не бывает:

```
docker  image  build  -f  regular.Dockerfile  -t  myimage:latest  . 
```

Если запустим с BuildKit - тоже ошибка:

```
DOCKER_BUILDKIT=1  docker  image  build  -f  regular.Dockerfile  -t  myimage:latest  .
```

Но если указать кастомный синтаксис (из файла `syntax.Dockerfile`), то сборка пройдёт успешно:

```
syntax.Dockerfile
```

Это работает так. Указанный в директиве `syntax` путь ведёт к docker-образу, который содержит в себе программу, которая переводит инструкции кастомного Dockerfile в обычные, с которыми билдер умеет работать.
Здесь очень простой пример. Другие реализации будут сложнее и глубже, но надеюсь суть ты ухватил.
