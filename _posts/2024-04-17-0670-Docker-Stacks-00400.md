---
layout: article
---

Начнем с контейнеров и пойдем выше. 

Контейнер, как ты помнишь, представляет собой упакованное в образ приложение, готовое к развёртыванию. В этой упаковке содержатся его собственные зависимости, он работает в собственной изолированной среде, и ему для работы требуется хостовое ядро. Мы видели кучу примеров примеров и сами работали с множеством контейнеров на протяжении этого курса. Примеры популярных контейнерных приложений: веб-сервисы на базе NodeJS, оперативного кэша, вроде Redis, базы данных, например MongoDB или MySQL. В зависимости от типа приложения они могут иметь немного экземпляров или большое количество реплик, редко масштабироваться или быть очень динамичными.

В кластере такой отдельный вид контейнеров может быть размещён на разные узлы, но их будет объединять общая сущность, которая называется служба или service. В этом случае у нас служба с NodeJS имеет три контейнера. Вторая служба, которая развернула Redis, имеет в себе лишь один экземпляр контейнера. Служба с MongoDB имеет в себе две реплики. Таким образом, над контейнерами появилась абстракция, обращаясь к которой мы можем управлять наборами одинаковых контейнеров.

Следующий уровень иерархии — это стек. Стек – это группа взаимосвязанных сервисов, которые вместе образуют целое приложение. В моём случае мой стек это:

- реплики веб-приложения на основе NodeJS
- служба с in-memory cache
- и служба базы данных с двумя экземплярами: primary и secondary.

Подход со службами позволяет мне контролировать каждый этаж моей архитектуры отдельно от других. Если какой-то из уровней не справляется, я могу расширить именно эту отдельную службу. Такой подход делает мое приложение распределенным, простым для управления и даёт возможность легкого масштабирования. Использование стеков позволяет мне автоматизировать развёртывание этого приложения в разных средах: у меня есть готовый шаблон для тестов, для стейджа и для прода. Благодаря этому, оттестированные изменения можно развернуть почти в реальном времени. Т.е. очень быстро.
