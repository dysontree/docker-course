---
layout: article
---

Давай посмотрим, как работаю ограничения cgroups. Но сначала давай подумаем, как мы решаем, на каком из серверов выполнить задачу? Ну, например, нам не приходит в голову мысль запускать приложения на сервере базы данных, поскольку у них будет конкуренция в ресурсах, и если какое-то приложение утянет все ресурсы на себя, база упадёт. 

Системы виртуализации помогают в этом - мы можем установить несколько виртуальных серверов, а на гипервизоре настроить желаемое количество аппаратных ресурсов. Но при простое приложения, выделенные в гипервизоре ядра также продолжат бездействовать. Но операционная система также умеет распределять ресурсы.

В настройках планировщика Linux есть параметр `nice`, которым мы можем указать, что какой-то из процессов более важный, и ему нужно дать больше времени для исполнения. Это работает относительно других процессов, поэтому ресурсы не простаивают. Замечательно, но проблема `nice` в том, что мы не можем с его помощью сказать, давай приоритет по процессору мы оставим как есть, но вот ввод-вывод повысим. Такие точные ограничения могут предложить cgroups.

Контрольные группы позволяют устанавливать ограничения на ресурсы для процессов и их потомков. Этот механизм ядро Linux использует для контроля ограничений на память, на swap, на процессор, на хранилище и на сетевой I/O. Группы безопасности придумали раньше Docker, в уже далёком 2007 году. Но Docker успешно использует их для создания своих изоляций.

Каждому контейнеру в Linux назначается контрольная группа, уникальная для этого контейнера. Все процессы в контейнере будут находиться в этой группе. Это означает, что нам не нужно контролировать ресурсы каждого процесса, запущенного в контейнере. Docker позволяет нам контролировать память, swap и CPU (на самом деле еще и GPU, но это другая история). Docker использует не все возможности cgroups, они умеют больше, например, такие неявные вещи, как маркировка сетевых пакетов для приоритизации трафика. Также стоит отметить, что данные для команды `docker container stats` тоже поступают из механизма cgroups.

Итак, Docker настраивает cgroups. Это действительно мощный метод, поскольку изменения происходят не только при создании контейнера, а их можно делать `на лету`. Вдобавок мы вполне можем управлять ими самостоятельно. 
