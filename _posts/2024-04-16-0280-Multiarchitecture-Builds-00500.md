---
layout: article
---

Как видишь, всё в порядке, как и ожидалось. Пока мы следовали подходу с одной архитектурой, которая такая же, как и у хоста. Теперь давай соберём этот образ для `linux/amd64` и `linux/arm64`.

```
DOCKER_BUILDKIT=1 docker buildx build --platform linux/amd64,linux/arm64 --tag helloworld:v2 .
```

Обрати внимание, что я изменил тег на `v2` и убрал параметр `--load`. Это потому, что отдельный хост не может работать с несколькими архитектурами, следовательно я могу использовать только экспортер для реджистри. 

Но я указал название образа `helloworld`, поэтому dockerhub будет считать мои образы библиотечными и не примет их. Без указания экспортера все собранные образы останутся внутри кэша сборщика. Мы еще до них доберёмся, но пока обрати внимание на пару вещей.

Из-за эмуляции, которая требуется при создании образов для неродных архитектур, сборка заняла у меня около 10 минут. Это оверхед qemu-виртуализации. В производственных сетапах мы можем использовать другие драйверы, что позволит помещать сборки на платформы, в которой базовая архитектура, на которой бежит сборщик, соответствует собираемой. Это должно значительно ускорить процесс. Также ранее я говорил, что buildkit будет стараться запустить всё, что возможно в параллельной манере, это тоже даёт нам ускорение.

Итак, мы не добавили `--push` в нашу сборку, о чём нам написало предупреждение в конце сборки. Таким образом, мы не можем запустить контейнеры из `v2`, но мы уверены, что сборка успешная, потому что Docker не показывал никаких ошибок. 

Если бы перед сборкой я написал полную нотацию репозитория к которому у меня есть доступ и построил бы для него, то образы бы залились в удаленный реджистри, и мы могли бы проверить их командой `docker manifest`. Но я поступлю иначе и выгружу оба образа в локальное хранилище по очереди.

Я перетегаю их как `helloworld:v2amd` и `helloworld:v2arm` и пересоберу.

```
DOCKER_BUILDKIT=1 docker buildx build --platform linux/amd64 --tag helloworld:v2amd --load .
DOCKER_BUILDKIT=1 docker buildx build --platform linux/arm64 --tag helloworld:v2arm --load .
```

Как видишь, на хосте у нас теперь оба образа. Это не один образ, а два разных, но иначе ограничения локального хоста не обойти.

```
docker image list
```

Проверю параметры образов:

```
docker image inspect helloworld:v2amd
```

```
docker image inspect helloworld:v2arm
```

Таким образом, если бы всё прошло прямым путём, то сборщик запушил оба образа в репозиторий под один тег. Они бы имели одинаковый дайджест, но разную платформу. Следовательно Dockers клиентов, которые хотят создать контейнер, будут пуллить подходящий образ, просто обращаясь по его тегу/дайджесту и сообщая реджистри, какая им требуется платформа.

Что же, это всё о том, как мы можем создавать multiarchitecture builds. Увидимся!
