---
layout: article
---
Процесс внутри контейнера все посчитал и остановился, поскольку ему стало нечего делать. В этом случае, когда все прошло хорошо, код выхода равен нулю.

```
docker container run ubuntu expr 6 + 7
```

```
docker  container  ls  -a
```

Еще контейнер может остановиться из-за сбоя. Например, передана неверная опция или отсутствует какой-то файл в образе, или какой-то внешний ресурс недоступен. Может быть 1001 причина. В этом случае контейнер завершается с ненулевым кодом выхода, и мы понимаем, что имел место сбой.

```
docker container run ubuntu expr six + 7
```

```
docker  container  ls  -a
```

Также работающий контейнер можно остановить вручную. Выполним команду `docker container stop`, которая, как мы уже знаем, сначала отправляет сигнал SIGTERM, за которым следует SIGKILL. Это приводит к принудительному завершению работы приложения. В этот момент, в зависимости от образа и того, как программное обеспечение в нем настроено для обработки сигналов, контейнер выходит с определенным кодом. Например, если процесс, работающий внутри контейнера, запрограммирован на обработку сигнала SIGTERM, который послала `container stop`, то он прибирает за собой и отключается, т.е. он корректно завершает работу. 

```
docker stop fb5b86763eaa
```

```
docker  container  ls  -a
```

При этом код выхода будет равен нулю. Если он не завершил свою работу, и пришлось отправить SIGKILL, это может привести к другому коду выхода, который может быть не нулевым. Так вот, руководствуясь этими кодами, мы понимаем, что именно произошло с контейнером. И мы можем настроить автоматический перезапуск контейнера, исходя из произошедшего события.
