---
layout: article
---
Команды `inspect` работают для отдельного docker-объекта. Но есть другие команды, которые показывают информацию о многих контейнерах. Если у нас десятки контейнеров на хосте, нам бы хотелось знать, сколько ресурсов они потребляют. Также, хотелось бы понимать, сколько в данный момент времени отдельный контейнер потребляет памяти и CPU. Это важно для планирования нагрузок, поскольку мы перестаем угадывать потребности наших приложений в разных режимах работы. В своей практике я видел разные варианты, как этого добиваются. Кто-то делал exec в контейнер и проверял информацию профилировщиков, кто-то писал сложные скрипты Linux, которые собирали данные о процессах на хосте и вели учёт, кто из них был лидером по потреблению. Кто-то использовал сторонние решения. Однако все это было костыльно и не очень эффективно.

```
docker container stats
```

В Docker есть встроенная функция, которая выводит список контейнеров с потреблением CPU, памяти, сети и диска. Команда как ты видишь: `docker container stats`. Она отобразит контейнеры с указанием того, сколько ресурсов они потребляют. Флаг `--no-stream` выводит данные один раз, без него вывод будет периодически обновляться. Здесь мы видим, что первый контейнер использует около 25% процессора, второй около 75%

Давай попробуем выяснить, что является причиной этого. Сначала проверим контейнер `stress75`. Для этого нужно просмотреть процессы в контейнере и понять, какой из них нагружает систему. Здесь есть несколько вариантов, как нам быть дальше. Мы можем сделать exec в контейнер, чтобы проверить эту информацию теми утилитами, что есть внутри контейнера. Для работы утилиты `top` внутри контейнера нам нужно дать терминал флагом `-t`:

```
docker container exec -t stress75 top -n 1
```

Альтернативно можно использовать команду `docker container top`, за которой следует имя контейнера или его ID, чтобы составить список процессов и их реальных PIDs, т.е. того, как они выглядят с docker-хоста. 

```groovy
docker container top stress75    
```

В нашем случае мы видим процесс `stress`, который исполняется внутри нашего контейнера. Внутри контейнера он имеет свой PID, но вот с точки зрения ядра это будет процесс с идентификатором 3784. Мы можем найти этот процесс в дереве процессов хоста:

```
ps aux
```

Ок, мы выяснили, что виновник проблем этот процесс.
