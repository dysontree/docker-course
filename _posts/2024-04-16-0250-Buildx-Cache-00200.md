---
layout: article
---
Итак, во-первых у этого сборщика появилась возможность использовать кэш из других билдов. Вот так это будет выглядеть в Dockerfile - к определённой инструкции `RUN` мы можем добавить некоторый файловый кэш при помощи опции `mount`. Мы указываем каталог, в котором приложения при сборке ожидают найти закэшированные файлы.

```
RUN \
--mount=type=cache,mode=0777,target=/var/cache/apt \
apt-get update && apt-get install -y git
```

Использование такого явного кэша с флагом `--mount` сохраняет содержимое целевого каталога и позволяет шарить его между сборками. Когда этот слой будет запущен на сборку, Docker сначала подгрузит данные из специального тома в директорию `/var/cache/apt`, и внутренний apt будет использовать эти файлы в своей работе. В конечный образ этот каталог не пойдёт, в образ попадёт только результат работы `apt`.

Польза подобного монтирования в том, что в теории мы можем иметь общий кэш индексов и пакетов для разных сборок. На практике это не совсем так. `apt` требует монопольного доступа, поэтому одновременная работа нескольких сборок требует дополнительной настройки. Также Docker отслеживает ID-сборок и периодически они не совпадают, после чего кэш перестраивается. 

Чтобы понять, о чём речь, давай разберём простой случай. У нас Dockerfile, который делает в слое `RUN` три вещи: 

- выводит сообщение (это нужно для тестов производительности)
- обновляет индекс пакетов
- скачивает и устанавливает пакеты в систему

```
FROM ubuntu
RUN \
# --mount=type=cache,target=/var/cache/apt,id=apt-cache,sharing=locked \
# --mount=type=cache,target=/var/lib/apt,id=apt-lib,sharing=locked \
  echo no-cache-layer-1 \
  && apt-get update \
  && apt-get install --yes --no-install-suggests --no-install-recommends \
  ca-certificates \
  cmake \
  gcc \
  g++ \
  gfortran \
  git \
  libc-dev \
  make 

```

Как видишь, команды пущены в одном слое, и если какая-то из них изменится, слой будет снова перестроен. Запускаю на сборку. Это занимает 69 секунд.

```
DOCKER_BUILDKIT=1 docker image build .
```

В данный момент наш слой находится в локальном кэше. Если я изменю сообщение команды `echo`, то кэш станет недействительным и Docker заново обновит индексы, скачает и установит пакеты.

```
DOCKER_BUILDKIT=1 docker image build .
```

Теперь это заняло 71 секунду. Это чуть дольше, поскольку в процесс могли добавиться сетевые задержки и то, сколько свободных мощностей было на сервере-сборщике. Теперь я добавлю конструкцию `--mount`. Также я изменю сообщение, чтобы быть уверенным, что слой будет собираться заново.

Теперь Docker создаст на этом локальном сборщике volume, в которой сохранит скачанные пакеты и списки с индексами репозиториев. Пока этот том пустой, соответственно мы не увидим прибавку в скорости сборки.

```
DOCKER_BUILDKIT=1 docker image build .
```

Но повторные сборки уже не будут заново качать файлы с архивами пакетов, поскольку `apt` найдёт их в директории, которая была подключена к этом слою.

```
DOCKER_BUILDKIT=1 docker image build .
```

Как видишь, мы получили выигрыш во времени в 6 секунд, т.е. около 10%, а также сэкономили трафик. 

Отметь, что мы каждый раз обновляли список пакетов командой `apt-get update`. Мы можем закэшировать и их, это даст выигрыш в производительности, но опасно потерей актуальности метаданных репозиториев. Как быть в этой ситуации - решать тебе как автору, поскольку ты лучше знаешь, какие пакеты требуются и как часто их нужно обновлять.
