---
layout: article
---
Т.е. скрипт `entrypoint.sh` получит в качестве аргумента путь к скрипту `run.sh`. Если заглянуть внутрь скриптов, то мы видим, что `entrypoint.sh` загружает библиотеки, формирует переменные окружения и далее передаёт работу скрипту из аргумента.

```
...
# Load libraries
. /opt/bitnami/scripts/liblog.sh
. /opt/bitnami/scripts/libbitnami.sh
. /opt/bitnami/scripts/libkafka.sh
...
```

Таким образом, если при старте данного контейнера мы передадим в CMD какую-то другую команду, т.е. переопределим дефолтную CMD, будет запущен не скрипт `run.sh`, а переданная команда, но ENTRYPOINT всё равно предварительно отработает и обогатит окружение этой команды переменными, загрузит библиотеки и т.д. Здесь мы переопределили CMD на команду `env`.

```
docker container run docker.io/bitnami/kafka:3.7 env
```

Как видишь, прежде чем вывести список переменных, точка входа произвела несколько действий и вывод `env` изменился. Таким образом, используя эти инструкции в паре, мы можем задать базовый слой настроек с помощью ENTRYPOINT и добавить кастомизацию при помощи CMD.

Мы можем переопределить точку входа при запуске при помощи опции `--entrypoint`, как ты видишь.

```
docker container run --entrypoint echo docker.io/bitnami/kafka:3.7 Hello DevOps!
```

Итоговая команда получилась `echo Hello DevOps!`, хотя я использовал тот же образ с `kafka`. 

Итак, считается, что `ENTRYPOINT` нужна для задания основного бинарного файла контейнера, а `CMD` для передачи туда аргументов. Но в процессе работы с образами ты будешь видеть, что это используется на усмотрение создателя образа, и жёсткого стандарта на это нет.
