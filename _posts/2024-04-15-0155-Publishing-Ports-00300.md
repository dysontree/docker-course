---
layout: article
---
А именно, чтобы весь трафик, поступивший на порт `80` docker-хоста был бы перенаправлен на порт `5000` внутрь docker-контейнера.

```
docker  container  run  -p  80:5000  rotorocloud/webapp
```

В Docker для этого есть удобный механизм. Мы можем указать опцию `-p` в команде `docker container run`, как ты видишь. Теперь Docker позаботится об этом, т.е. он сам настроит механизмы ОС в части пересылки трафика, чтобы пользователь мог получить доступ к моему приложению, перейдя по адресу `http://10.0.0.13:80`. 

```
curl 10.0.0.13:80
```

Эта функция также даёт возможность запускать несколько экземпляров этого приложения и сопоставлять их с разными портами на хосте. 

```
docker  container  run  -p  8000:5000  rotorocloud/webapp
```

```
docker  container  run  -p  8001:5000  rotorocloud/webapp
```

Приложения не будут конфликтовать, а запросы будут приходить именно тому приложению, для которого они предназначаются. Нам не обязательно запускать одно и тоже приложение. Это могут быть любые контейнеры, а приложения в них могут работать на различных портах.

Например, здесь мы запускаем экземпляр MySQL, который поднимает базу данных и прослушивает порт MySQl, который по умолчанию `3306`. Рядом другой экземпляр MySQl на другом порту, скажем, `8306`. 

```
docker  container  run  -p  3306:3306  mysql
```

```
docker  container  run  -p  8306:3306  mysql
```

Таким образом, мы можем запустить столько приложений, сколько требуется и сопоставить их с нужным количеством портов. Ограничение в том, что мы не можем использовать один и тот же порт на docker-хосте несколько раз. Допустим, мы запускаем другой контейнер MySQL и пытаемся выставить его наружу на тот же порт хоста 8306. 

```
container  run  -p  8306:3306  mysql
```

Это не сработает, поскольку порт хоста уже занят слушающим на нем контейнером с базой. Так что мы не сможем `смаппить` один порт в два контейнера средствами Docker.
