---
layout: article
---
Давай посмотрим, как нам самостоятельно выгрузить и загрузить кэш.

```
FROM alpine

RUN apk add git

RUN git clone https://github.com/rotoro-cloud/docker-advanced.git
```

Во время сборки мы устанавливаем git и клонируем репозиторий курса. Всё это остаётся в образе. Наша задача локально сохранить кэш этой сборки и передать его хосту, который данный образ не собирал и не скачивал, но мог бы использовать его слои для своих работ по сборке образов.

```
docker buildx create --use --driver=docker-container
```

Как я говорил, опции `--cache-*` не работают со стандартным драйвером сборки, поэтому мы меняем его на `docker-container`. Теперь я запущу сборку:

```
docker buildx build --cache-to type=local,dest=/opt/docker-cache -f Dockerfile-1 .
```

Здесь мы указали `type=local`, что означает, что кэш слоя должен быть выгружен в файловую систему хоста, и `dest=/opt/docker-cache`, в которой указали путь.

Если заглянуть туда, мы увидим blob-файлы слоёв образа, подобно как мы делали командой `docker image save` ранее в курсе. 

```
tree -L 1 /opt/docker-cache
```

Я создал `Dockerfile-2`, который использует такие же инструкции, как и предыдущий, но добавляет одну свою:

```
FROM alpine

RUN apk add git

RUN git clone https://github.com/rotoro-cloud/docker-advanced.git

RUN echo Hello DevOps!
```

Если в данный момент я запущу его на сборку, все пройдет очень быстро, поскольку все слои кроме последнего находятся в локальном кэше билдера.

Теперь представим, что мы перенесли эти файлы на другой хост, на котором нет этого образа. Для этого сделаем полную очистку сборщиков и образов:

```
docker builder prune -af
docker buildx prune -af
docker image prune -af
docker volume prune -af
```

Теперь любая сборка хоста будет как `с чистого листа`.

```
docker buildx build -f Dockerfile-2 . 
```

Как видишь, сборка с нуля заняла 9 секунд. Снова сброшу билдеры и образы, но в этот раз пуск будет с другой командой:

```
docker buildx build --cache-from type=local,src=/opt/docker-cache -f Dockerfile-2 .
```

Мы получили 5 секунд вместо 9. Экономия 40%. Всё потому, что первые слои не строились, а были скопированы из директории `/opt/docker-cache` и интегрированы в новый образ.

Это мощная штука, поскольку она может складывать и забирать кэш из реестров образов.

В инструкции `--cache-from` мы использовали параметр `src`, который представляет собой локальный путь к файлам кэша. В это размещение мы выгрузили файлы предыдущей сборкой. Если заглянуть в `index.json`, мы увидим `digest` или хэш этого образа. Здесь локально лежит последний кэш предыдущей сборки. При каждой выгрузке `index.json` перезаписывается, но файлы слоёв остаются. Если вдруг нам нужно сделать шаг назад и использовать кэш более ранней версии, мы можем достать его из локального хранилища при помощи параметра `digest`, указав его в как ты видишь.

```
type=local,ref=/opt/docker-cache,digest=sha256:6982c70595cb91769f61cd1e064cf5f41d5357387bab
```
