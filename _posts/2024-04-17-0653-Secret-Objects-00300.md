---
layout: article
---

Это может быть не только файл, но и поток вывода, как ты видишь здесь:

```
echo "postgres" | docker secret create my_secret2 -
```

В продуктовых развёртываниях конфиденциальную информацию в отрытом виде в файлах никто не держит, поэтому в secret-объекты информация попадает не из локальных файлов, а её предоставляют специальные решения по хранению секретов - vaults. Таким образом, эти объекты интегрируют внешние безопасные хранилища с нашим кластером.

Ок, после создания, передаём secret в службу:

```
docker service update --secret-add src=my_secret2,target=/tmp/secret pg_db
```

Теперь secret доступен в виде незашифрованного файла в файловой системе контейнера.

```
docker exec -it b652ea38d876 cat /tmp/secret
```

Как ты помнишь, секрет находится в оперативной памяти. Давай это проверим:

```
docker exec -it b652ea38d876 df -h | grep secret
```

После того, как реплика службы закончит работу, файловая система в RAM разрушается и секретная информация становится недоступна на этом узле. Поскольку нет никаких монтирований на хост, соседние контейнеры не могут получить доступ к данным во время работы.

Причина, по которой secrets инжектируются в контейнер в незашифрованном виде в том, что для расшифровки приложениям потребуются секретные ключи, что может привести к компрометации всего хранилища.

По умолчанию внутри контейнера secrets будут находиться по пути `/run/secrets/<secret_name>`. Длинная нотация позволяет монтировать их в другое место.

Чтобы отозвать secret используй команду:

```
docker service update --secret-rm my_secret2 pg_db
```

Для удаления есть команда `docker secret rm`, здесь ограничение в том, чтобы удаляемые secrets не были привязаны ни к одной из служб. Это поведение очень похоже на объекты конфигураций.

```
docker secret rm my_secret2
```

И это всё о секретах в Docker. Увидимся!
