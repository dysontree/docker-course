---
layout: article
---
```
FROM  ubuntu

RUN  apt-get  update  

RUN  apt-get  install  -y  python3  python3-pip

RUN  pip3  install  flask

COPY  app.py  /opt/app.py

ENTRYPOINT  FLASK_APP=/opt/app.py  flask  run  --host=0.0.0.0  --port=5000 CMD vs Entrypoint
```

В Dockerfile в инструкции `COPY` у содержится указание по копированию файлов исходного кода в образ. Но как демон Docker узнаёт, где именно находятся эти файлы, которые нужно скопировать? 

Как ты помнишь, мы запускаем такого вида команду: `docker build`, чтобы создать образ, описанный в этом Dockerfile. 

```
docker  image  build  .  -f  Dockerfile  -t  rotorocloud/webapp
```

Обрати внимание, что при запуске команды сборки мы указываем путь к расположению Dockerfile, а также тег, который нужно применить к собранному образу. Мы можем не указывать эти опции для файла и тега. Если избавиться от них, то после создания к образу не будет применен никакой тег. Образ будет доступен лишь по его ID. Если не указать Dockerfile, то Docker использует тот, что так прямо и называется - `Dockerfile`, поэтому этот параметр часто упускают. Но даже в таком виде образ все равно подготовиться, поскольку эти флаги не являются обязательными.

```
docker  image  build  .
```

Поэтому мы можем обрезать команду сборки до вида `docker build .`. Что здесь является действительно важным, и без чего не обойтись - это символ точки (.) - именно эта опция указывает путь к месту, где хранится Dockerfile, другие файлы и относительно которого будет производиться вся сборка. Это может быть текущий каталог, как указано здесь, или это может быть путь к другому каталогу. И вот именно этот путь называется контекстом сборки.

```
docker  image  build  /opt/web-app
```

После запуска команды сборки демон Docker ищет Dockerfile, а также остальные файлы, участвующие в этой сборке (т.е. упомянутые в Dockerfile) в переданной ему директории контекста. Таким образом, если в указанной нами текущей директории (если мы передали `.`, то это указывает на текущий каталог) не будет Dockerfile или каких-то других файлов, явно указанных в инструкции по сборке, то сборка провалится. Но зачем всё так сложно? Почему бы не убрать этот контекст, и не собирать всегда из текущей директории?

До сих пор мы предполагали, что и клиент Docker (то есть команда docker, которую мы запускаем), и демон Docker (который dockerd) находятся на одном хосте, а файлы, нужные для сборки приложения, также находятся на этом же хосте. Но что, если демон Docker управляется удалённо, т.е. находится на другом хосте, не на той машине, с которой мы управляем сборкой? Что тогда происходит с файлами в контексте сборки?

Действительно, запускать команды из Docker CLI можно и со своего ноутбука, и с сервера CICD, и еще откуда-то. Docker Daemon может быть отдельным сервером, на котором Docker работает удаленно. Мы можем работать с таким удалённым демоном используя переменную среды `DOCKER_HOST`, и в курсе для новичков мы смотрели, как это делается. Но как в такой ситуации будет работать сборка? 

Docker daemon должен иметь доступ к файлам для создания образа. Таким образом, всякий раз, когда сборка инициируется запуском команды `docker build`, dockerd передает файлы из контекста сборки в свой временный каталог. По умолчанию это копируется в `/var/lib/docker/tmp`. Мы можем запустить команду `ls` во время сборки и убедиться в этом сами.

```
ls /var/lib/docker/tmp/docker-builder353889520/
```

Имей в виду, что такая передача файлов происходит всегда, даже если демон Docker находится на этом же хосте. Все файлы, указанные в контексте сборки, копируются в этот временный каталог демона. Поэтому большие по объёму файлов сборки могут немного подвисать в начале команды build на экране с информацией об общем размере файлов, переданных демону Docker.

Ок, теперь становится понятно, почему важно убедиться, что у нас есть все необходимые для сборки образа файлы в контексте сборки. Также становится понятно, почему в директориях, которые мы используем в качестве контекста, не должно быть разного файлового `мусора`. Например, временных файлов, каких-то логов и прочих не нужных для сборки вещей. Все, что мы не удалили из каталога будет передано демону Docker. Это увеличит время сборки, потребует больше сетевого трафика и дискового пространства. Поэтому в контексте сборки следует располагать лишь только необходимые файлы. Но это не всегда возможно.
