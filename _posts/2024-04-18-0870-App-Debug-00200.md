---
layout: article
---

На самом деле, отладка контейнерного приложения не так уж и отличается от дебага обычного процесса в системе, за исключением того, что инструменты будут другими. Docker предоставляет несколько хороших инструментов, которые помогут нам в этом. И конечно мы будем использовать системные инструменты.

Для отладки контейнеров важно понимать, какие именно процессы принадлежат приложению, какие самому докеру, а какие системе. Также контейнеры могут совместно использовать хранение и сетевые интерфейсы.

Контейнеры, это не виртуализация. Процессы контейнера - это просто процессы на самом хосте Linux. Это означает, что вы можем получить много информации о том, что контейнер делает из самой операционной системы. Поэтому мы можем получить примерно одинаковую информацию из команды `ps` и `docker container top`. Или мы можем использовать более тяжеловесные `docker container exec` или `nsenter`. Вопрос привычки и удобства.

Одна из первых вещей, которую нужно знать при отладке контейнера, — это что именно происходит внутри него. Мы разбирали команду `docker container top` в начале курса. Это самый простой, но не единственный способ узнать, какие процессы принадлежат контейнеру.

```
docker container run --rm -d --name nginx-debug --rm -p 80:80 nginx:latest
```

Я запустил команду `docker container top`, а далее передал ей имя контейнера.

```
docker container top nginx-debug
```

В ответ мы получаем вывод, похожий на команду `ps`. Но есть отличия. Основное в том, что UID пользователей даются с точки зрения контейнера. Со стороны хоста это будет выглядеть по-другому. Также отметь, что пользователя с этим UID даже не будет в файле `/etc/passwd` контейнера. Это потому что, Linux не требует, чтобы UID имел связанного с ним именованного пользователя.

Давай посмотрим на конкретный пример этого. Допустим на моём хосте с Debian 11 есть UID = 7 и он имеет имя `lp`:

```
id 7
```

Если мы запустим такую команду в контейнере с ОС `Fedora`, то увидим, что UID = 7 связан с совсем другим именем пользователя.

```
docker container run --rm fedora:latest cat /etc/passwd | grep 'x:7'
```

Теперь запустим контейнер на исполнение и проверим процессы на docker-хосте.

```
docker container run --rm -d -u 7 fedora:latest sleep 120
```

```
ps aux | grep 'sleep 120' | grep -v grep
```

Мы видим, что с точки зрения хоста это будет пользователь `lp`. Поэтому важен UID, а не имя. В связи с этим новички часто путаются, когда в выводе `ps` с хоста они видят, что демон `mongod` запустил пользователь `zabbix`. Поэтому важен только UID.

Аналогично и с файловой системой. Пути, отображаемые в выводе ps, относятся к контейнеру, а не к хосту. В этих случаях нам важно знать, как именно это устроено внутри контейнера. Мы можем использовать инструменты Docker, чтобы посмотреть, что именно находится внутри контейнера. Но это не единственный способ, и в ситуации отладки нам могут быть полезны дополнительные техники.
